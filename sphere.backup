let shape = seen.Shapes.sphere(2).scale(200)
seen.Colors.randomSurfaces2(shape)

let scene = new seen.Scene({
  model: seen.Models.default().add(shape),
  viewport: seen.Viewports.center(w - 300, h)
})
let context = seen.Context('seen-canvas', scene)
context.render()

let dragger = new seen.Drag('seen-canvas', {inertia : false})
dragger.on('drag.rotate', (e) => {
  let xform = seen.Quaternion.xyToTransform(e.offsetRelative[0], e.offsetRelative[1])
  shape.transform(xform)
  context.render()
})


useEffect(() => {
  let h = document.body.getBoundingClientRect().height
  let w = document.body.getBoundingClientRect().width

  let model = seen.Models.default()

  let scale = 140

  let cube = seen.Shapes.unitcube().scale(scale).fill('#eeeeee').translate((scale / 2) * -1, scale, (scale / 2) * -1)
  // let cube2 = seen.Shapes.unitcube().scale(scale).fill('#A21CAF').translate((scale / 2) * -1,scale * 0,(scale / 2) * -1)
  // let cube3 = seen.Shapes.unitcube().scale(scale).fill('#FDE047').translate((scale / 2) * -1,scale * -1,(scale / 2) * -1)
  // let cube4 = seen.Shapes.unitcube().scale(scale).fill('#F97316').translate((scale / 2) * -1,scale * 0,(scale / 2) * -1)
  //   .translate(scale, 0, 0)

  let m = 0.1, n = 1-m

  let panel = new seen.Shape('panel', [new seen.Surface([
    seen.P(m,m,0),
    seen.P(m,n,0),
    seen.P(n,n,0),
    seen.P(n,m,0),
  ])]).translate(0, 0, -0.01).scale(scale).fill('#18181B').translate((scale / 2) * -1, scale, (scale / 2) * -1)

  let mi = m + 0.05, nix = 0.82, niy = 0.85

  let panelInput = new seen.Shape('panel', [new seen.Surface([
    seen.P(mi,mi,0),
    seen.P(mi,nix,0),
    seen.P(niy,nix,0),
    seen.P(niy,mi,0),
  ])]).translate(0, 0, -0.02).scale(scale).fill('#f8f8f8').translate((scale / 2) * -1, scale, (scale / 2) * -1)

  model.add(cube)
  model.add(panel)
  model.add(panelInput)
  // model.add(cube2)
  // model.add(cube3)
  // model.add(cube4)
  model.transform(seen.Quaternion.pointAngle({x: 0, y: 0.5, z: 0}, 1).toMatrix())
  //model.transform(seen.Quaternion.xyToTransform(40, 0))
  //model.transform(seen.Quaternion.xyToTransform(0, 40))

  let scene = new seen.Scene({
    model: model,
    viewport: seen.Viewports.center(w - 300, h),
    camera: new seen.Camera({projection: seen.Projections.ortho()}).translate(0, -60, 0).rotx(0.5),
    cullBackfaces: false, fractionalPoints: true,
  })

  let context = seen.Context('seen-canvas', scene)
  context.render()

  let dragger = new seen.Drag('seen-canvas', {inertia : false})
  dragger.on('drag.rotate1', (e) => {
    let xform = seen.Quaternion.xyToTransform(e.offsetRelative[0], 0)
    model.transform(xform)
    context.render()
  })
}, [])

let orthoScale = 0.008

let scene = new Scene()
//let camera = new OrthographicCamera((w/-2)*orthoScale, (w/2)*orthoScale, (h/2)*orthoScale, (h/-2)*orthoScale, 0.1, 1000)

let geometry = new BufferGeometry();

let vertices = new Float32Array([
  -1.0, -1.0,  1.0, // v0
   1.0, -1.0,  1.0, // v1
   1.0,  1.0,  1.0, // v2
  -1.0,  1.0,  1.0, // v3
]);

const indices = [
  0, 1, 2, 3
];

geometry.setIndex( indices );
geometry.setAttribute( 'position', new BufferAttribute( vertices, 4 ) );

let wireframe = new WireframeGeometry(geometry);
let lines = new LineSegments(wireframe);
lines.material.depthTest = true;
lines.material.opacity = 0.25;
lines.material.transparent = true;
lines.material.color = 0xff00ee;

console.log(lines.material)

ctx.scene.add(lines)


let geometry = new BufferGeometry();
let v1 = -0.43, v2=0.43, v3 = 0.6001
let vertices = new Float32Array([
   v1, v1, v3, // p0
   v2, v1, v3, // p1
   v2, v2, v3, // p2

   v2, v2, v3, // p2
   v1, v2, v3, // p3
   v1, v1, v3, // p0
]);

geometry.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );

let material = new MeshPhongMaterial({color: 0xffffff});
let panel = new Mesh(geometry, material);
ctx.scene.add(panel)
